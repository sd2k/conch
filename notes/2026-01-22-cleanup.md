# Cleanup and Architecture Simplification

**Date**: 2026-01-22

## Summary

Simplified the conch architecture by removing the unused component model executor and consolidating to a single executor type that uses `InstancePre` for efficient per-call instantiation.

## Changes Made

### Removed

1. **`crates/conch/src/wasm.rs`** - The component model executor (`ShellExecutor`)
   - Was using `wasmtime::component::bindgen!` but the shell doesn't implement WIT exports
   - Shell uses C-style FFI exports (`execute`, `get_stdout`, etc.), not component model
   - Was dead code - never actually worked

2. **`crates/conch/wit/shell.wit`** - Vestigial WIT interface
   - Had custom VFS imports (`vfs-read`, `vfs-readdir`, etc.) that weren't being used
   - The VFS will be implemented via WASI filesystem shadowing instead (eryx pattern)
   - Removed the custom imports, file was then deleted entirely

3. **Duplicate FFI functions** - Consolidated `conch_core_*` and `conch_*`
   - Was: `conch_executor_*` (component) + `conch_core_executor_*` (wasip1)
   - Now: Just `conch_executor_*` backed by `CoreShellExecutor`

4. **Go `CoreExecutor` type** - Unified to single `Executor` type

### Improved

1. **`wasm_core.rs`** - Now uses `InstancePre` pattern (like eryx)
   - Engine and pre-linked instance are shared across executions (in `Arc`)
   - Each execution creates only a fresh `Store` with new WASI context
   - No re-linking overhead per call
   - Added `ResourceLimiter` for memory limits
   - Uses epoch-based CPU interruption

2. **FFI API** - Cleaner, unified interface
   ```c
   // Lifecycle
   ConchExecutor* conch_executor_new_embedded();
   ConchExecutor* conch_executor_new(const char* path);
   ConchExecutor* conch_executor_new_from_bytes(const uint8_t* data, size_t len);
   void conch_executor_free(ConchExecutor* executor);
   
   // Execution
   ConchResult* conch_execute(ConchExecutor* executor, const char* script);
   ConchResult* conch_execute_with_limits(ConchExecutor* executor, const char* script,
                                          uint64_t max_cpu_ms, uint64_t max_memory_bytes,
                                          uint64_t max_output_bytes, uint64_t timeout_ms);
   void conch_result_free(ConchResult* result);
   
   // Utilities
   const char* conch_last_error();
   uint8_t conch_has_embedded_shell();
   ```

3. **Go bindings** - Simplified to match
   - Single `Executor` type
   - `ResourceLimits` struct with `DefaultLimits()` helper
   - `Execute(script)` and `ExecuteWithLimits(script, limits)` methods

### Architecture Now

```
┌─────────────────────────────────────────────────────────┐
│  Host (Go/Rust application)                             │
│                                                         │
│  ┌───────────────────────────────────────────────────┐  │
│  │  CoreShellExecutor                                │  │
│  │  - Arc<Engine> (shared)                           │  │
│  │  - Arc<InstancePre<ShellState>> (pre-linked)      │  │
│  └───────────────────────────────────────────────────┘  │
│                          │                              │
│                 execute() creates:                      │
│                          │                              │
│  ┌───────────────────────▼───────────────────────────┐  │
│  │  Store<ShellState>    (fresh per call)            │  │
│  │  - WasiP1Ctx         (WASI context)               │  │
│  │  - stdout/stderr pipes                            │  │
│  │  - ResourceLimiter                                │  │
│  └───────────────────────────────────────────────────┘  │
│                          │                              │
│            instance_pre.instantiate_async()             │
│                          │                              │
│  ┌───────────────────────▼───────────────────────────┐  │
│  │  conch-shell.wasm (wasm32-wasip1)                 │  │
│  │  - brush-core (bash interpreter)                  │  │
│  │  - brush-builtins (cat, grep, etc.)               │  │
│  └───────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

## VFS Status

The `ContextFs` and `ContextProvider` in `vfs.rs` are fully implemented with:
- Path parsing (`/ctx/self/tools/<id>/result.json`, etc.)
- Access control (parent/child agent permissions)
- Lazy loading via `ContextProvider` trait
- Caching of tool call data

**Not yet wired up** - needs WASI filesystem shadowing on the host side (the eryx pattern). This will be easier if/when we migrate to wasip2.

## What's Left

1. **VFS Integration** - Wire `ContextFs` to WASM execution via WASI shadowing
2. **wasip2 Migration** - Optional but recommended (see `wasip1-vs-wasip2.md`)
3. **JS Integration** - Once on wasip2, can use jco to transpile for browser/Node

## Files Modified

- `crates/conch/src/lib.rs` - Removed `wasm` module and `ShellExecutor` export
- `crates/conch/src/wasm_core.rs` - Added `InstancePre`, `ResourceLimiter`
- `crates/conch/src/ffi.rs` - Consolidated API, removed component model functions
- `tests/go/conch.go` - Unified to single `Executor` type
- `tests/go/conch_test.go` - Updated tests for new API
- `AGENTS.md` - Updated to reflect simplified architecture

## Files Deleted

- `crates/conch/src/wasm.rs`
- `crates/conch/wit/shell.wit`
